diff --git a/configure b/configure
index 1e8b974..1105180 100755
--- a/configure
+++ b/configure
@@ -268,7 +268,7 @@ fi
 
 # Some patched GCC builds have these defaults messed up...
 tryflag CFLAGS_AUTO -fno-stack-protector
-tryldflag LDFLAGS_AUTO -Wl,--hash-style=sysv
+tryldflag LDFLAGS_AUTO -Wl,--hash-style=both
 
 # Disable dynamic linking if ld is broken and can't do -Bsymbolic-functions
 LDFLAGS_DUMMY=
diff --git a/include/arpa/nameser.h b/include/arpa/nameser.h
index 778d3e7..b9ee665 100644
--- a/include/arpa/nameser.h
+++ b/include/arpa/nameser.h
@@ -1,6 +1,8 @@
 #ifndef _ARPA_NAMESER_H
 #define _ARPA_NAMESER_H
 
+#include <stdint.h>
+
 #define __NAMESER	19991006
 #define NS_PACKETSZ	512
 #define NS_MAXDNAME	1025
diff --git a/include/dirent.h b/include/dirent.h
index a51526d..c19f7d5 100644
--- a/include/dirent.h
+++ b/include/dirent.h
@@ -7,6 +7,9 @@ extern "C" {
 
 #define __NEED_ino_t
 #define __NEED_off_t
+#ifdef _BSD_SOURCE
+#define __NEED_size_t
+#endif
 
 #include <bits/alltypes.h>
 
diff --git a/include/dlfcn.h b/include/dlfcn.h
index dea74c7..e98c8ca 100644
--- a/include/dlfcn.h
+++ b/include/dlfcn.h
@@ -18,6 +18,16 @@ char  *dlerror(void);
 void  *dlopen(const char *, int);
 void  *dlsym(void *, const char *);
 
+#ifdef _GNU_SOURCE
+typedef struct {
+	const char *dli_fname;
+	void *dli_fbase;
+	const char *dli_sname;
+	void *dli_saddr;
+} Dl_info;
+int dladdr(void *, Dl_info *);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/stdalign.h b/include/stdalign.h
new file mode 100644
index 0000000..b6e50ae
--- /dev/null
+++ b/include/stdalign.h
@@ -0,0 +1,15 @@
+#ifndef _STDALIGN_H
+#define _STDALIGN_H
+
+/* this whole header only works in C11 or with compiler extensions */
+#if __STDC_VERSION__ < 201112L && defined( __GNUC__)
+#define _Alignas(t) __attribute__((__aligned__(t)))
+#define _Alignof(t) __alignof__(t)
+#endif
+
+#define alignas _Alignas
+#define alignof _Alignof
+#define __alignas_is_defined 1
+#define __alignof_is_defined 1
+
+#endif
diff --git a/include/stdio.h b/include/stdio.h
index 19ab8bc..9aa2f78 100644
--- a/include/stdio.h
+++ b/include/stdio.h
@@ -90,7 +90,9 @@ int putc(int, FILE *);
 int putchar(int);
 
 char *fgets(char *, int, FILE *);
+#if __STDC_VERSION__ < 201112L
 char *gets(char *);
+#endif
 
 int fputs(const char *, FILE *);
 int puts(const char *);
diff --git a/include/stdio_ext.h b/include/stdio_ext.h
index d979bdc..e3ab7fd 100644
--- a/include/stdio_ext.h
+++ b/include/stdio_ext.h
@@ -5,6 +5,8 @@
 extern "C" {
 #endif
 
+#include <stdio.h>
+
 #define FSETLOCKING_QUERY 0
 #define FSETLOCKING_INTERNAL 1
 #define FSETLOCKING_BYCALLER 2
diff --git a/include/stdlib.h b/include/stdlib.h
index 0a8de86..1749cb3 100644
--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -38,11 +38,14 @@ void *malloc (size_t);
 void *calloc (size_t, size_t);
 void *realloc (void *, size_t);
 void free (void *);
+void *aligned_alloc(size_t alignment, size_t size);
 
 void abort (void);
 int atexit (void (*) (void));
 void exit (int);
 void _Exit (int);
+int at_quick_exit (void (*) (void));
+void quick_exit (int);
 
 char *getenv (const char *);
 
diff --git a/include/sys/sem.h b/include/sys/sem.h
index 15d8b68..add3f1c 100644
--- a/include/sys/sem.h
+++ b/include/sys/sem.h
@@ -5,6 +5,11 @@ extern "C" {
 #endif
 
 #define __NEED_size_t
+#define __NEED_pid_t
+#define __NEED_time_t
+#ifdef _GNU_SOURCE
+#define __NEED_struct_timespec
+#endif
 #include <bits/alltypes.h>
 
 #include <sys/ipc.h>
@@ -58,8 +63,6 @@ int semget(key_t, int, int);
 int semop(int, struct sembuf *, size_t);
 
 #ifdef _GNU_SOURCE
-#define __NEED_struct_timespec
-#include <bits/alltypes.h>
 int semtimedop(int, struct sembuf *, size_t, const struct timespec *);
 #endif
 
diff --git a/src/env/__stack_chk_fail.c b/src/env/__stack_chk_fail.c
index c6d0feb..eac852b 100644
--- a/src/env/__stack_chk_fail.c
+++ b/src/env/__stack_chk_fail.c
@@ -14,7 +14,8 @@ void __init_ssp(size_t *auxv)
 	for (i=0; auxv[i] && auxv[i]!=AT_RANDOM; i+=2);
 	if (auxv[i]) memcpy(&canary, (void *)auxv[i+1], sizeof canary);
 	else canary = (uintptr_t)&canary * 1103515245;
-	__stack_chk_guard = self->canary = canary;
+	a_cas_l(&__stack_chk_guard, 0, canary);
+	self->canary = __stack_chk_guard;
 }
 
 void __stack_chk_fail(void)
diff --git a/src/exit/at_quick_exit.c b/src/exit/at_quick_exit.c
new file mode 100644
index 0000000..85c3d26
--- /dev/null
+++ b/src/exit/at_quick_exit.c
@@ -0,0 +1,29 @@
+#include <stdlib.h>
+#include "libc.h"
+
+#define COUNT 32
+
+static void (*funcs[COUNT])(void);
+static int count;
+static int lock[2];
+
+void __funcs_on_quick_exit()
+{
+	void (*func)(void);
+	LOCK(lock);
+	while (count > 0) {
+		func = funcs[--count];
+		UNLOCK(lock);
+		func();
+		LOCK(lock);
+	}
+}
+
+int at_quick_exit(void (*func)(void))
+{
+	if (count == 32) return -1;
+	LOCK(lock);
+	funcs[count++] = func;
+	UNLOCK(lock);
+	return 0;
+}
diff --git a/src/exit/atexit.c b/src/exit/atexit.c
index 1b40cb9..c31f3dc 100644
--- a/src/exit/atexit.c
+++ b/src/exit/atexit.c
@@ -21,9 +21,8 @@ void __funcs_on_exit()
 	int i;
 	void (*func)(void *), *arg;
 	LOCK(lock);
-	for (; head; head=head->next) {
-		for (i=COUNT-1; i>=0 && !head->f[i]; i--);
-		if (i<0) continue;
+	for (; head; head=head->next) for (i=COUNT-1; i>=0; i--) {
+		if (!head->f[i]) continue;
 		func = head->f[i];
 		arg = head->a[i];
 		head->f[i] = 0;
diff --git a/src/exit/quick_exit.c b/src/exit/quick_exit.c
new file mode 100644
index 0000000..18d5288
--- /dev/null
+++ b/src/exit/quick_exit.c
@@ -0,0 +1,15 @@
+#include <stdlib.h>
+#include "syscall.h"
+#include "atomic.h"
+#include "libc.h"
+
+static void dummy() { }
+weak_alias(dummy, __funcs_on_quick_exit);
+
+void quick_exit(int code)
+{
+	static int lock;
+	while (a_swap(&lock, 1)) __syscall(SYS_pause);
+	__funcs_on_quick_exit();
+	_Exit(code);
+}
diff --git a/src/ldso/dladdr.c b/src/ldso/dladdr.c
new file mode 100644
index 0000000..265bb68
--- /dev/null
+++ b/src/ldso/dladdr.c
@@ -0,0 +1,9 @@
+#define _GNU_SOURCE
+#include <dlfcn.h>
+
+int __dladdr(void *, Dl_info *);
+
+int dladdr(void *addr, Dl_info *info)
+{
+	return __dladdr(addr, info);
+}
diff --git a/src/ldso/dynlink.c b/src/ldso/dynlink.c
index f55c6f1..b8c26ac 100644
--- a/src/ldso/dynlink.c
+++ b/src/ldso/dynlink.c
@@ -1,3 +1,4 @@
+#define _GNU_SOURCE
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -53,6 +54,7 @@ struct dso {
 	int refcnt;
 	Sym *syms;
 	uint32_t *hashtab;
+	uint32_t *ghashtab;
 	char *strings;
 	unsigned char *map;
 	size_t map_len;
@@ -76,9 +78,11 @@ static int rtld_used;
 static int ssp_used;
 static int runtime;
 static int ldd_mode;
+static int ldso_fail;
 static jmp_buf rtld_fail;
 static pthread_rwlock_t lock;
 static struct debug debug;
+static size_t *auxv;
 
 struct debug *_dl_debug_addr = &debug;
 
@@ -94,7 +98,15 @@ static void decode_vec(size_t *v, size_t *a, size_t cnt)
 	}
 }
 
-static uint32_t hash(const char *s0)
+static int search_vec(size_t *v, size_t *r, size_t key)
+{
+	for (; v[0]!=key; v+=2)
+		if (!v[0]) return 0;
+	*r = v[1];
+	return 1;
+}
+
+static uint32_t sysv_hash(const char *s0)
 {
 	const unsigned char *s = (void *)s0;
 	uint_fast32_t h = 0;
@@ -105,7 +117,16 @@ static uint32_t hash(const char *s0)
 	return h & 0xfffffff;
 }
 
-static Sym *lookup(const char *s, uint32_t h, struct dso *dso)
+static uint32_t gnu_hash(const char *s0)
+{
+	const unsigned char *s = (void *)s0;
+	uint_fast32_t h = 5381;
+	for (; *s; s++)
+		h = h*33 + *s;
+	return h;
+}
+
+static Sym *sysv_lookup(const char *s, uint32_t h, struct dso *dso)
 {
 	size_t i;
 	Sym *syms = dso->syms;
@@ -118,20 +139,61 @@ static Sym *lookup(const char *s, uint32_t h, struct dso *dso)
 	return 0;
 }
 
+static Sym *gnu_lookup(const char *s, uint32_t h1, struct dso *dso)
+{
+	Sym *sym;
+	char *strings;
+	uint32_t *hashtab = dso->ghashtab;
+	uint32_t nbuckets = hashtab[0];
+	uint32_t *buckets = hashtab + 4 + hashtab[2]*(sizeof(size_t)/4);
+	uint32_t h2;
+	uint32_t *hashval;
+	uint32_t n = buckets[h1 % nbuckets];
+
+	if (!n) return 0;
+
+	strings = dso->strings;
+	sym = dso->syms + n;
+	hashval = buckets + nbuckets + (n - hashtab[1]);
+
+	for (h1 |= 1; ; sym++) {
+		h2 = *hashval++;
+		if ((h1 == (h2|1)) && !strcmp(s, strings + sym->st_name))
+			return sym;
+		if (h2 & 1) break;
+	}
+
+	return 0;
+}
+
 #define OK_TYPES (1<<STT_NOTYPE | 1<<STT_OBJECT | 1<<STT_FUNC | 1<<STT_COMMON)
 #define OK_BINDS (1<<STB_GLOBAL | 1<<STB_WEAK)
 
 static void *find_sym(struct dso *dso, const char *s, int need_def)
 {
-	uint32_t h = hash(s);
+	uint32_t h = 0, gh = 0;
 	void *def = 0;
-	if (h==0x6b366be && !strcmp(s, "dlopen")) rtld_used = 1;
-	if (h==0x6b3afd && !strcmp(s, "dlsym")) rtld_used = 1;
-	if (h==0x595a4cc && !strcmp(s, "__stack_chk_fail")) ssp_used = 1;
+	if (dso->ghashtab) {
+		gh = gnu_hash(s);
+		if (gh == 0xf9040207 && !strcmp(s, "dlopen")) rtld_used = 1;
+		if (gh == 0xf4dc4ae && !strcmp(s, "dlsym")) rtld_used = 1;
+		if (gh == 0x1f4039c9 && !strcmp(s, "__stack_chk_fail")) ssp_used = 1;
+	} else {
+		h = sysv_hash(s);
+		if (h == 0x6b366be && !strcmp(s, "dlopen")) rtld_used = 1;
+		if (h == 0x6b3afd && !strcmp(s, "dlsym")) rtld_used = 1;
+		if (h == 0x595a4cc && !strcmp(s, "__stack_chk_fail")) ssp_used = 1;
+	}
 	for (; dso; dso=dso->next) {
 		Sym *sym;
 		if (!dso->global) continue;
-		sym = lookup(s, h, dso);
+		if (dso->ghashtab) {
+			if (!gh) gh = gnu_hash(s);
+			sym = gnu_lookup(s, gh, dso);
+		} else {
+			if (!h) h = sysv_hash(s);
+			sym = sysv_lookup(s, h, dso);
+		}
 		if (sym && (!need_def || sym->st_shndx) && sym->st_value
 		 && (1<<(sym->st_info&0xf) & OK_TYPES)
 		 && (1<<(sym->st_info>>4) & OK_BINDS)) {
@@ -171,7 +233,8 @@ static void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stri
 					dso->name, name);
 				if (runtime) longjmp(rtld_fail, 1);
 				dprintf(2, "%s\n", errbuf);
-				_exit(127);
+				ldso_fail = 1;
+				continue;
 			}
 			sym_size = sym->st_size;
 		} else {
@@ -323,8 +386,11 @@ static void decode_dyn(struct dso *p)
 	size_t dyn[DYN_CNT] = {0};
 	decode_vec(p->dynv, dyn, DYN_CNT);
 	p->syms = (void *)(p->base + dyn[DT_SYMTAB]);
-	p->hashtab = (void *)(p->base + dyn[DT_HASH]);
 	p->strings = (void *)(p->base + dyn[DT_STRTAB]);
+	if (dyn[0]&(1<<DT_HASH))
+		p->hashtab = (void *)(p->base + dyn[DT_HASH]);
+	if (search_vec(p->dynv, dyn, DT_GNU_HASH))
+		p->ghashtab = (void *)(p->base + *dyn);
 }
 
 static struct dso *load_library(const char *name)
@@ -450,7 +516,8 @@ static void load_deps(struct dso *p)
 					p->strings + p->dynv[i+1], p->name);
 				if (runtime) longjmp(rtld_fail, 1);
 				dprintf(2, "%s\n", errbuf);
-				_exit(127);
+				ldso_fail = 1;
+				continue;
 			}
 			if (runtime) {
 				tmp = realloc(*deps, sizeof(*tmp)*(ndeps+2));
@@ -518,6 +585,22 @@ static size_t find_dyn(Phdr *ph, size_t cnt, size_t stride)
 	return 0;
 }
 
+static void find_map_range(Phdr *ph, size_t cnt, size_t stride, struct dso *p)
+{
+	size_t min_addr = -1, max_addr = 0;
+	for (; cnt--; ph = (void *)((char *)ph + stride)) {
+		if (ph->p_type != PT_LOAD) continue;
+		if (ph->p_vaddr < min_addr)
+			min_addr = ph->p_vaddr;
+		if (ph->p_vaddr+ph->p_memsz > max_addr)
+			max_addr = ph->p_vaddr+ph->p_memsz;
+	}
+	min_addr &= -PAGE_SIZE;
+	max_addr = (max_addr + PAGE_SIZE-1) & -PAGE_SIZE;
+	p->map = p->base + min_addr;
+	p->map_len = max_addr - min_addr;
+}
+
 static void do_init_fini(struct dso *p)
 {
 	size_t dyn[DYN_CNT] = {0};
@@ -538,7 +621,7 @@ void _dl_debug_state(void)
 
 void *__dynlink(int argc, char **argv)
 {
-	size_t *auxv, aux[AUX_CNT] = {0};
+	size_t aux[AUX_CNT] = {0};
 	size_t i;
 	Phdr *phdr;
 	Ehdr *ehdr;
@@ -547,6 +630,7 @@ void *__dynlink(int argc, char **argv)
 	struct dso *const lib = builtin_dsos+1;
 	struct dso *const vdso = builtin_dsos+2;
 	char *env_preload=0;
+	size_t vdso_base;
 
 	/* Find aux vector just past environ[] */
 	for (i=argc+1; argv[i]; i++)
@@ -580,6 +664,8 @@ void *__dynlink(int argc, char **argv)
 	lib->name = lib->shortname = "libc.so";
 	lib->global = 1;
 	ehdr = (void *)lib->base;
+	find_map_range((void *)(aux[AT_BASE]+ehdr->e_phoff),
+		ehdr->e_phnum, ehdr->e_phentsize, lib);
 	lib->dynv = (void *)(lib->base + find_dyn(
 		(void *)(aux[AT_BASE]+ehdr->e_phoff),
 		ehdr->e_phnum, ehdr->e_phentsize));
@@ -599,6 +685,8 @@ void *__dynlink(int argc, char **argv)
 		app->name = argv[0];
 		app->dynv = (void *)(app->base + find_dyn(
 			(void *)aux[AT_PHDR], aux[AT_PHNUM], aux[AT_PHENT]));
+		find_map_range((void *)aux[AT_PHDR],
+			aux[AT_PHNUM], aux[AT_PHENT], app);
 	} else {
 		int fd;
 		char *ldname = argv[0];
@@ -635,9 +723,7 @@ void *__dynlink(int argc, char **argv)
 	decode_dyn(app);
 
 	/* Attach to vdso, if provided by the kernel */
-	for (i=0; auxv[i]; i+=2) {
-		size_t vdso_base = auxv[i+1];
-		if (auxv[i] != AT_SYSINFO_EHDR) continue;
+	if (search_vec(auxv, &vdso_base, AT_SYSINFO_EHDR)) {
 		ehdr = (void *)vdso_base;
 		phdr = (void *)(vdso_base + ehdr->e_phoff);
 		for (i=ehdr->e_phnum; i; i--, phdr=(void *)((char *)phdr + ehdr->e_phentsize)) {
@@ -651,7 +737,6 @@ void *__dynlink(int argc, char **argv)
 		decode_dyn(vdso);
 		vdso->prev = lib;
 		lib->next = vdso;
-		break;
 	}
 
 	/* Initial dso chain consists only of the app. We temporarily
@@ -682,6 +767,7 @@ void *__dynlink(int argc, char **argv)
 	reloc_all(app->next);
 	reloc_all(app);
 
+	if (ldso_fail) _exit(127);
 	if (ldd_mode) _exit(0);
 
 	/* Switch to runtime mode: any further failures in the dynamic
@@ -772,6 +858,8 @@ void *dlopen(const char *file, int mode)
 		p->global = 1;
 	}
 
+	if (ssp_used) __init_ssp(auxv);
+
 	_dl_debug_state();
 
 	do_init_fini(tail);
@@ -784,7 +872,7 @@ end:
 static void *do_dlsym(struct dso *p, const char *s, void *ra)
 {
 	size_t i;
-	uint32_t h;
+	uint32_t h = 0, gh = 0;
 	Sym *sym;
 	if (p == RTLD_NEXT) {
 		for (p=head; p && (unsigned char *)ra-p->map>p->map_len; p=p->next);
@@ -798,12 +886,23 @@ static void *do_dlsym(struct dso *p, const char *s, void *ra)
 		if (!res) goto failed;
 		return res;
 	}
-	h = hash(s);
-	sym = lookup(s, h, p);
+	if (p->ghashtab) {
+		gh = gnu_hash(s);
+		sym = gnu_lookup(s, gh, p);
+	} else {
+		h = sysv_hash(s);
+		sym = sysv_lookup(s, h, p);
+	}
 	if (sym && sym->st_value && (1<<(sym->st_info&0xf) & OK_TYPES))
 		return p->base + sym->st_value;
 	if (p->deps) for (i=0; p->deps[i]; i++) {
-		sym = lookup(s, h, p->deps[i]);
+		if (p->deps[i]->ghashtab) {
+			if (!gh) gh = gnu_hash(s);
+			sym = gnu_lookup(s, gh, p->deps[i]);
+		} else {
+			if (!h) h = sysv_hash(s);
+			sym = sysv_lookup(s, h, p->deps[i]);
+		}
 		if (sym && sym->st_value && (1<<(sym->st_info&0xf) & OK_TYPES))
 			return p->deps[i]->base + sym->st_value;
 	}
@@ -813,6 +912,67 @@ failed:
 	return 0;
 }
 
+int __dladdr(void *addr, Dl_info *info)
+{
+	struct dso *p;
+	Sym *sym;
+	uint32_t nsym;
+	char *strings;
+	size_t i;
+	void *best = 0;
+	char *bestname;
+
+	pthread_rwlock_rdlock(&lock);
+	for (p=head; p && (unsigned char *)addr-p->map>p->map_len; p=p->next);
+	pthread_rwlock_unlock(&lock);
+
+	if (!p) return 0;
+
+	sym = p->syms;
+	strings = p->strings;
+	if (p->hashtab) {
+		nsym = p->hashtab[1];
+	} else {
+		uint32_t *buckets;
+		uint32_t *hashval;
+		buckets = p->ghashtab + 4 + (p->ghashtab[2]*sizeof(size_t)/4);
+		sym += p->ghashtab[1];
+		for (i = 0; i < p->ghashtab[0]; i++) {
+			if (buckets[i] > nsym)
+				nsym = buckets[i];
+		}
+		if (nsym) {
+			nsym -= p->ghashtab[1];
+			hashval = buckets + p->ghashtab[0] + nsym;
+			do nsym++;
+			while (!(*hashval++ & 1));
+		}
+	}
+
+	for (; nsym; nsym--, sym++) {
+		if (sym->st_shndx && sym->st_value
+		 && (1<<(sym->st_info&0xf) & OK_TYPES)
+		 && (1<<(sym->st_info>>4) & OK_BINDS)) {
+			void *symaddr = p->base + sym->st_value;
+			if (symaddr > addr || symaddr < best)
+				continue;
+			best = symaddr;
+			bestname = strings + sym->st_name;
+			if (addr == symaddr)
+				break;
+		}
+	}
+
+	if (!best) return 0;
+
+	info->dli_fname = p->name;
+	info->dli_fbase = p->base;
+	info->dli_sname = bestname;
+	info->dli_saddr = best;
+
+	return 1;
+}
+
 void *__dlsym(void *p, const char *s, void *ra)
 {
 	void *res;
@@ -830,6 +990,10 @@ void *__dlsym(void *p, const char *s, void *ra)
 {
 	return 0;
 }
+int __dladdr (void *addr, Dl_info *info)
+{
+	return 0;
+}
 #endif
 
 char *dlerror()
diff --git a/src/malloc/aligned_alloc.c b/src/malloc/aligned_alloc.c
new file mode 100644
index 0000000..d623420
--- /dev/null
+++ b/src/malloc/aligned_alloc.c
@@ -0,0 +1,51 @@
+#include <stdlib.h>
+#include <stdint.h>
+#include <errno.h>
+
+/* This function should work with most dlmalloc-like chunk bookkeeping
+ * systems, but it's only guaranteed to work with the native implementation
+ * used in this library. */
+
+void *aligned_alloc(size_t align, size_t len)
+{
+	unsigned char *mem, *new, *end;
+	size_t header, footer;
+
+	if ((align & -align & -sizeof(void *)) != align) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	if (len > SIZE_MAX - align) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	if (align <= 4*sizeof(size_t)) {
+		if (!(mem = malloc(len)))
+			return NULL;
+		return mem;
+	}
+
+	if (!(mem = malloc(len + align-1)))
+		return NULL;
+
+	header = ((size_t *)mem)[-1];
+	end = mem + (header & -8);
+	footer = ((size_t *)end)[-2];
+	new = (void *)((uintptr_t)mem + align-1 & -align);
+
+	if (!(header & 7)) {
+		((size_t *)new)[-2] = ((size_t *)mem)[-2] + (new-mem);
+		((size_t *)new)[-1] = ((size_t *)mem)[-1] - (new-mem);
+		return new;
+	}
+
+	((size_t *)mem)[-1] = header&7 | new-mem;
+	((size_t *)new)[-2] = footer&7 | new-mem;
+	((size_t *)new)[-1] = header&7 | end-new;
+	((size_t *)end)[-2] = footer&7 | end-new;
+
+	if (new != mem) free(mem);
+	return new;
+}
diff --git a/src/malloc/memalign.c b/src/malloc/memalign.c
index 61f456e..a594c63 100644
--- a/src/malloc/memalign.c
+++ b/src/malloc/memalign.c
@@ -3,11 +3,5 @@
 
 void *memalign(size_t align, size_t len)
 {
-	void *mem;
-	int ret;
-	if ((ret = posix_memalign(&mem, align, len))) {
-		errno = ret;
-		return 0;
-	}
-	return mem;
+	return aligned_alloc(align, len);
 }
diff --git a/src/malloc/posix_memalign.c b/src/malloc/posix_memalign.c
index 2ae928c..42cf274 100644
--- a/src/malloc/posix_memalign.c
+++ b/src/malloc/posix_memalign.c
@@ -1,47 +1,10 @@
 #include <stdlib.h>
-#include <stdint.h>
 #include <errno.h>
 
-/* This function should work with most dlmalloc-like chunk bookkeeping
- * systems, but it's only guaranteed to work with the native implementation
- * used in this library. */
-
 int posix_memalign(void **res, size_t align, size_t len)
 {
-	unsigned char *mem, *new, *end;
-	size_t header, footer;
-
-	if ((align & -align & -sizeof(void *)) != align) return EINVAL;
-	if (len > SIZE_MAX - align) return ENOMEM;
-
-	if (align <= 4*sizeof(size_t)) {
-		if (!(mem = malloc(len)))
-			return errno;
-		*res = mem;
-		return 0;
-	}
-
-	if (!(mem = malloc(len + align-1)))
-		return errno;
-
-	header = ((size_t *)mem)[-1];
-	end = mem + (header & -8);
-	footer = ((size_t *)end)[-2];
-	new = (void *)((uintptr_t)mem + align-1 & -align);
-
-	if (!(header & 7)) {
-		((size_t *)new)[-2] = ((size_t *)mem)[-2] + (new-mem);
-		((size_t *)new)[-1] = ((size_t *)mem)[-1] - (new-mem);
-		*res = new;
-		return 0;
-	}
-
-	((size_t *)mem)[-1] = header&7 | new-mem;
-	((size_t *)new)[-2] = footer&7 | new-mem;
-	((size_t *)new)[-1] = header&7 | end-new;
-	((size_t *)end)[-2] = footer&7 | end-new;
-
-	if (new != mem) free(mem);
-	*res = new;
+	void *mem = aligned_alloc(align, len);
+	if (!mem) return errno;
+	*res = mem;
 	return 0;
 }
diff --git a/src/misc/ffs.c b/src/misc/ffs.c
index 2f7cb32..673ce5a 100644
--- a/src/misc/ffs.c
+++ b/src/misc/ffs.c
@@ -1,9 +1,7 @@
 #include <strings.h>
+#include "atomic.h"
 
 int ffs(int i)
 {
-	unsigned int j = i;
-	for (i=1; j && !(j&1); j>>=1, i++);
-	if (j) return i;
-	return 0;
+	return i ? a_ctz_l(i)+1 : 0;
 }
diff --git a/src/stdio/fopen.c b/src/stdio/fopen.c
index 084cc73..0d5b1af 100644
--- a/src/stdio/fopen.c
+++ b/src/stdio/fopen.c
@@ -5,7 +5,6 @@ FILE *fopen(const char *filename, const char *mode)
 	FILE *f;
 	int fd;
 	int flags;
-	int plus = !!strchr(mode, '+');
 
 	/* Check for valid initial mode character */
 	if (!strchr("rwa", *mode)) {
@@ -14,9 +13,10 @@ FILE *fopen(const char *filename, const char *mode)
 	}
 
 	/* Compute the flags to pass to open() */
-	if (plus) flags = O_RDWR;
+	if (strchr(mode, '+')) flags = O_RDWR;
 	else if (*mode == 'r') flags = O_RDONLY;
 	else flags = O_WRONLY;
+	if (strchr(mode, 'x')) flags |= O_EXCL;
 	if (*mode != 'r') flags |= O_CREAT;
 	if (*mode == 'w') flags |= O_TRUNC;
 	if (*mode == 'a') flags |= O_APPEND;
-- 
1.7.3.4

--- a/src/ldso/dynlink.c
+++ b/src/ldso/dynlink.c
@@ -572,7 +572,7 @@ static void free_all(struct dso *p)
 	struct dso *n;
 	while (p) {
 		n = p->next;
-		if (p->map) free(p);
+		if (p->map && p!=libc && p!=head) free(p);
 		p = n;
 	}
 }
-- 
1.7.3.4

